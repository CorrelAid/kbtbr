---
title: "Response overview"
output:
  github_document:
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
devtools::load_all()
library(kbtbr)
library(dplyr)
library(purrr)
library(tidyr)

# utility function to remove the base url and the format=json part from the urls 
# that are already part of the urls in the asset list
# TODO: discuss whether our get functions should also take full urls 
removeBaseUrl <- function(url){
  input_url <- gsub("https://kobo.correlaid.org/api/v2/", "", url)
  gsub("\\?format=json", "", input_url)
}
```


```{r list-assets}
base_url <- Sys.getenv("KBTBR_BASE_URL")
token <- Sys.getenv("KBTBR_TOKEN")

kobo <- Kobo$new(base_url, token)
assets <- kobo$get("assets/")$results
```

Get an element of each asset type:

```{r}
first_of_type <- assets %>% 
  group_by(asset_type) %>% 
  arrange(desc(deployment__submission_count)) %>% # reverse sort by submissions to get a survey with submissions
  slice(1)
first_of_type$asset_type
```

**Important**: `url` and `data` URLs contain almost all of the relevant information.

# Use cases
## Get general information about an asset (Timm)

Get the name of an asset from the list of assets:
```{r}
colnames(assets)
```


Get the uid of an asset from the list of assets:
```{r}
assets$uid
```

Additional information to the assets:
```{r}
summary(str(assets, max.level = 1))
```




## Get responses to a survey (Timm)



```{r}
url_data <- first_of_type$url %>% 
  map(function(url) {
    kobo$get(removeBaseUrl(url))
  }) %>% 
  set_names(paste0(first_of_type$asset_type, "_url"))

str(url_data$survey_url, max.level = 1)
```


Retrieve the `content` from the survey_url:
```{r}
str(url_data$survey_url$content, max.level = 2)
```




## Get permissions of an asset ()

## Get form metadata (Frie)

## File Downloads (Frie)


# Overview / Comparison

## Data from the `url` url
`GET` the data from the `url` URL.

```{r}
# data from "url" url
url_data <- first_of_type$url %>% 
  map(function(url) {
    kobo$get(removeBaseUrl(url))
  }) %>% 
  set_names(paste0(first_of_type$asset_type, "_url"))
```



```{r}
assets_names <- tibble(name = colnames(assets), type = "assets")
# extract the names from the object
url_data %>% 
  map_dfr(function(el) {
    names(el)
  }) %>% 
  pivot_longer(everything(), names_to = "type", values_to = "name") %>% 
  bind_rows(assets_names) %>% # combine with assets_df 
  janitor::tabyl(name, type) %>%   
  knitr::kable()
```
All asset types have the same elements in their `url` return object. We also see that quite a lot of metadata seems to be already available in the assets data frame that we get from the `assets/` endpoint (cross-checking that the values are indeed the same would be beneficial - an attempt is made down below).

## Data from the `data` url

```{r}
data_data <- first_of_type$data %>% 
  map(function(url) {
    # "data" url seems to be 404 except for surveys, so try-catch it
    # might also be different if we use questions, blocks, templates more seriously?
    tmp <- tryCatch(
      kobo$get(removeBaseUrl(url))$results,
      error = function(e) e$message
    )
    tmp
  }) %>% 
  set_names(paste(first_of_type$asset_type, "data", sep = "_"))

str(data_data, max.level = 2)
```
For the `data` url, we get a mixed pattern. For survey objects, the results contain the submissions to the survey as a data frame or an empty list if there are no submissions (_not_ an empty data frame with the variables!). For the template and the block types, we get a 404, for the question type a 400 (bad request). This must be further investigated whether this is a bug of the CorrelAid server or as intended, e.g. by testing this on the official Kobo server. Most of the metadata for questions, templates and blocks is in the "content" element of the `url` data - see below - so it might be well that there is intentionally no "data" for this type. 

# In depth analysis
**in bold** are elements that seem to be particularly interesting for us and the construction of response classes.

## Asset data frame

```{r}
colnames(assets)
```


- **`asset_type`**
```{r}
table(assets$asset_type)
```
- **`url`** and **`data`**: urls that'll give us more information about the specific assets
```{r}
assets %>% 
  select(url, data)
```
- general metadata:
  - **`name`**: name of the asset
  - **`owner`** and **`owner__username`**: the api url for the owner and the human-readable username
- **`uid`**: the unique id of the asset, used in the urls.. but i suppose it doesn't make a lot of sense to use this to construct urls ourselves given that they are always nicely handed to us by the API
- `settings`: sector, country where it was deployed, description given by the user
```{r}
colnames(assets$settings)
str(assets$settings)
```
- `version` and `deployment*` columns: information about the version and the current deployment
```{r}
assets %>% 
  select(starts_with("deployment"), version_id)
```

- `permissions`: permissions for this asset, one row per user and permission given.
```{r}
str(assets$permissions[[1]], max.level = 1)
```


## Survey
```{r}
surveyObject <- url_data$survey_url
```

In the following you can see a summary of the information you can retrieve from the `surveyObject`, which is a list of `r length(surveyObject)` elements. The elements of the type `list` of the `surveyObject` have to be accessed separately to get the resprective sublists (number of sublists given in column `Length`). Elements of type `NULL` do not comprise any information and hence, are not displayed separately below.  

```{r}
summary(surveyObject)
```

Here you have a more detailed overview with the elements of type character, `logical` and `numeric` displayed. 

```{r}
str(surveyObject, max.level = 1)
```


Finally, all the sublists displayed separately in - roughly - decreasing order of interest, whereby the sublist `content` might be of particular interest.

```{r}
surveyObject$content  
```

```{r}
surveyObject$settings
```
```{r}
surveyObject$downloads 
```

```{r}
surveyObject$summary
```

```{r}
surveyObject$deployment__links 
```


```{r}
surveyObject$permissions  
```


```{r}
surveyObject$deployed_versions 
```


```{r}
surveyObject$deployment__links 
```


```{r}
surveyObject$deployment__data_download_links 
```

```{r}
#surveyObject$report_styles  # commented out because quite long but empty
surveyObject$report_custom  
surveyObject$map_styles 
surveyObject$map_custom 
```

```{r}
surveyObject$embeds 
```

```{r}
surveyObject$assignable_permissions 
```



## Question

```{r}
question_url_data <- url_data$question_url
str(question_url_data, max.level = 1)
```



### Content 
The `content` list shows us more information / metadata about the question:

```{r}
question_url_data$content
```
This corresponds to the `survey` sheet of the question in XLSForm which we can check by comparing to the XLS downloadable  here: [https://kobo.correlaid.org/api/v2/assets/a7AV5JhRHKf8EWGBJLswwC.xls](https://kobo.correlaid.org/api/v2/assets/a7AV5JhRHKf8EWGBJLswwC.xls). 


```{r}
# TODO: figure out how to download this with R - the downloads data frame has a weird format query argument set to json.xls which probably comes from getting the data with format=json instead of via the browser interface
question_url_data$downloads
download_url <- question_url_data$downloads %>% filter(format == "xls") %>% pull(url)
```

The `start` and `end` rows are there because Kobo will by default always collect metadata about the start and end of the survey (cf [XLSForm documentation](https://xlsform.org/en/#metadata))

as we saw above in the comparison table, quite a bit of metadata is also contained in the assets data frame. 
```{r}
common_names <- intersect(names(question_url_data), colnames(assets))
common_names
```

let's see whether they're actually the same
```{r}
question_df <- assets %>% filter(uid == question_url_data$uid)

# for each of the names, extract the object and compare
comparison_df <- common_names %>% 
  map_dfr(function(name) {
    # from assets dataframe
    from_asset <- question_df[[name]]
    from_url_data <- question_url_data[[name]]
    df <- tibble(
      name = name,
      class_asset = class(from_asset),
      length_asset = length(from_asset),
      class_url_data = class(from_url_data),
      is_identical = identical(from_asset, from_url_data))
    df
  })
  
comparison_df 
```

Look at those which are not identical, they seem to be mostly rooted in differences in serialization (`data.frame` vs `list`):
```{r}
question_df$parent
```
